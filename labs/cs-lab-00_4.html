<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CS Lab 0.4</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="cmake---часть-1">0.4 - CMake - часть 1</h1>
<blockquote>
<p>Лабораторная работа 0.4 для студентов курса “Основы программирования” 1 курса кафедры ИУ5 МГТУ им Н.Э. Баумана.</p>
</blockquote>
<h2 id="содержание">Содержание</h2>
<ol>
<li><a href="#%D1%86%D0%B5%D0%BB%D1%8C-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B">Цель работы</a></li>
<li><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5">Введение</a></li>
<li><a href="#%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B8">Системы сборки</a></li>
<li><a href="#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B2-cmake">Ввод в CMake</a></li>
<li><a href="#cmake-best-practices">CMake best practices</a></li>
<li><a href="#%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-clang-tidy-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-cmake">Запуск clang-tidy через CMake</a></li>
<li><a href="#%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-clang-format-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-cmake">Запуск clang-format через CMake</a></li>
<li><a href="#%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D0%B0%D1%8F-%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-%D1%81-%D0%B4%D0%B5%D0%B1%D0%B0%D0%B3%D0%B3%D0%B5%D1%80%D0%BE%D0%BC">Настраиваемая сборка с дебаггером</a></li>
<li><a href="#%D0%B8%D1%82%D0%BE%D0%B3%D0%BE%D0%B2%D1%8B%D0%B9-%D0%B2%D0%B8%D0%B4-cmake-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D0%B0">Итоговый вид CMake конфига</a></li>
</ol>
<h2 id="цель-работы">Цель работы</h2>
<p>Познакомиться с системами сборки для приложений на C++. Научиться базово собирать приложение с использованием CMake.</p>
<h2 id="введение">Введение</h2>
<p>В данной лабораторной работе будут покрыты следующие темы:</p>
<ul>
<li>Краткий ввод в системы сборки;</li>
<li>Как писать CMake конфиги для сборки приложений на C++;</li>
<li>Настраиваемая сборка (на примере сборки отдельной версии приложения для дебаггера).</li>
</ul>
<h2 id="системы-сборки">Системы сборки</h2>
<p>В текущий момент, при выполнении лабораторных работ сборка самого приложения осуществляется через запуск компилятора вручную, с подачей ему соответствующих флагов и прочих аргументов.</p>
<p>В реальности проекты могут состоять из сотен и тысяч файлов, организованных в сложную иерархию директорий. Сами эти файлы могут компилироваться не в один исполняемый файл (т.н. <strong>цель</strong>), а в множество разных. В частности, это могут быть не только исполняемые файлы, но и библиотеки. Каждая из целей может требовать собственный уникальный (или частично уникальный) набор файлов, флагов, предварительный запуск каких-то скриптов (например, для кодогенерации) и т.п.</p>
<p>Помимо этого, абсолютное большинство крупных проектов полагаются на большое количество разнообразных зависимостей - разного вида библиотек, реализующих тот или иной функционал, которые разрабатываются другими людьми и командами.</p>
<p>Также, в средних и больших проектах стоит проблема времени компиляции. Разработка приложений, обычно, осуществляется инкрементально. Т.е. за раз изменяется/добавляется небольшое количество файлов с кодом. Таким образом, нет необходимости заново компилировать те файлы, которые не были затронуты изменениями. Однако, при запуске компилятора вручную, все файлы компилируются заново, независимо от того, менялись они или нет. Это может привести к длительной компиляции, которая может исчисляться десятками минут и даже часами.</p>
<p>Чтобы решить эти и другие проблемы существуют системы сборки.</p>
<p>Исторически сложилось, что C++ не имеет какой-то дефолтной инфраструктуры: одного конкретного компилятора, системы сборки, менеджера пакетов (зависимостей), линтеров и т.п. Поэтому существует множество разных решений.</p>
<p>Системы сборки делятся на низкоуровневые и высокоуровневые. Низкоуровневые (такие как <strong>Make</strong>, <strong>Ninja</strong>) зависят от конкретной операционной системы и конфигурируются по-разному в зависимости от компиляторов и прочих инструментов. Высокоуровневые же предоставляют дополнительный уровень абстракции, который позволяет упростить написание конфигов для кроссплатформенной сборки, и используют низкоуровневые системы сборки для своей работы.</p>
<p>На данном курсе используется система сборки <strong>CMake</strong> - одна из наиболее распространенных высокоуровневых систем сборки для C++. Конфиг файлы для <strong>CMake</strong> пишутся на собственном скриптовом языке.</p>
<h2 id="ввод-в-cmake">Ввод в CMake</h2>
<p><strong>CMake</strong> использует регистронезависимый скриптовый язык. Это значит, что команды можно писать как в нижнем, так и в верхнем регистре.</p>
<p>Проекты, использующие <strong>CMake</strong>, содержат один или несколько конфиг файлов, которые всегда имеют одно и то же название: <strong>CMakeLists.txt</strong>. Внутри одной директории находится только один конфиг файл. Самый основной находится прямо в корне проекта. При необходимости (когда нужно делить проект на отдельные модули, где описывается своя логика сборки) заводятся дополнительные конфиг файлы во вложенных директориях.</p>
<blockquote>
<p>Прежде чем продолжать выполнение работы, убедитесь, что у вас установлен CMake как минимум версии 3.20. Также рекомендуется установить расширения CMake и CMake Tools для VS Code.</p>
</blockquote>
<p>Для примера создадим проект <strong>Cmake-Example</strong> в VS Code со следующим содержимым:</p>
<pre><code>Cmake-Example/
├── CMakeLists.txt
└── main.cpp
</code></pre>
<p>Содержимое файла <strong>main.cpp</strong> не имеет значение. Предположим, это будет обычный “Hello, World!”.</p>
<p>Вставьте в <strong>CMakeLists.txt</strong> следующее (с # начинаются комментарии):</p>
<pre class=" language-cmake"><code class="prism  language-cmake"># указывает минимальную версию CMake
cmake_minimum_required(VERSION 3.20)

# название проекта
project(Example)

# указание на то, что надо создать исполняемый файл с названием Example (название цели), на вход компилятору будет подан файл main.cpp
add_executable(Example main.cpp)
# для цели Example будет использован двадцатый стандарт
set_property(TARGET Example PROPERTY CXX_STANDARD 20)

</code></pre>
<p>Для сборки проекта, как правило, заводят отдельную директорию. Обычно ее называют <strong>build</strong> (или схожим образом).</p>
<pre><code>mkdir build
cd build
</code></pre>
<p>Прежде чем собрать сам проект непосредственно, нужно сгенерировать файлы, необходимые для сборки. Файлы обычно генерируются <strong>один раз</strong>. Но если в конфиг файл были внесены изменения, то их необходимо сгенерировать <strong>заново</strong>. Для этого в директории <strong>build</strong>:</p>
<pre><code>cmake ..
</code></pre>
<p>Данная команда сгенерирует файлы, нужные для сборки проекта, используя конфиг файл, находящийся в директории выше (в данном примере в директории <strong>Cmake-Example</strong>).</p>
<p>Чтобы собрать сам проект, необходимо ввести следующую команду:</p>
<pre><code>cmake --build .
</code></pre>
<p>Команда соберет все цели, указанные во всех конфигах в текущую директорию. Цели, указанные в конфиг файлах во вложенных директориях, будут собраны с сохранением исходной иерархии.</p>
<p>В данном примере будет собран исполняемый файл <strong>Example</strong>. Данную команду нужно вводить каждый раз, если нужно заново собрать цель с учетом изменений в исходном коде. При этом перекомпилируются только те файлы, которые были изменены (или были затронуты изменениями, например, внесенными в заголовочные файлы).</p>
<p>Исполняемый файл <strong>Example</strong>, находящийся в директории <strong>build</strong>, можно запустить как обычно.</p>
<h2 id="cmake-best-practices">CMake best practices</h2>
<p>Документация - <a href="https://cmake.org/">https://cmake.org/</a></p>
<p>При написании конфиг файлов следует руководствоваться теми же соображениями, что и при написании кода. Это активное использование переменных, разделение на семантические блоки и на отдельные модули в разные конфиги, использование новых команд (по отношению к старым), указание минимально возможного скоупа для команд (опция PRIVATE в соответствующих командах) и т.д.</p>
<p><strong>CMake</strong> имеет множество встроенных переменных, значения которых зависят от окружения (операционная система, установленные инструменты и т.п.) и конфигурации сборки. Также можно заводить собственные переменные (строковые, булевые и т.п.).</p>
<p>Значения встроенных переменных можно менять вручную, но по возможности это не рекомендуется. Вместо этого следует использовать отдельные команды, которые сами поменяют/дополнят содержимое этих переменных.</p>
<p>Например, вместо следующей команды:</p>
<pre class=" language-cmake"><code class="prism  language-cmake">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wpedantic")
</code></pre>
<p>которая <strong>дополнит</strong> переменную, содержащую флаги для компилятора новыми флагами, следует использовать другую команду:</p>
<pre class=" language-cmake"><code class="prism  language-cmake">target_compile_options(Example PRIVATE -Wall -Wextra -Werror -Wpedantic)
</code></pre>
<p>Данная команда добавит эти же флаги компиляции только для указанной цели <strong>Example</strong> с приватным скоупом.</p>
<p>Для указания файлов с исходным кодом рекомендуется использовать отдельные переменные, в которых перечисляются эти файлы. Часто их называют <strong>SOURCES</strong> и <strong>HEADERS</strong> для .cpp и заголовочных файлов соответственно. При наличии множества целей используются более специфичные названия.</p>
<p>Категорически не рекомендуется использовать команду <strong>file</strong> (<a href="https://cmake.org/cmake/help/latest/command/file.html">https://cmake.org/cmake/help/latest/command/file.html</a>) для формирования списка исходных файлов, т.к. это затрудняет разделение файлов по модулям между разными целями для больших проектов, скрывает конкретный список исходных файлов, может привести к проблемам с работой в тех IDE, которые полагаются на <strong>CMake</strong> для умной подсветки синтаксиса (например, CLion).</p>
<p>Пример простого конфига с учетом best practices:</p>
<pre class=" language-cmake"><code class="prism  language-cmake">cmake_minimum_required(VERSION 3.20)

project(Example)

# файлы перечисляются либо через пустую строку, либо через пробел
set(SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/main.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/File2.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/File3.cpp
)

set(HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/Header1.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Header2.hpp
)

# новая цель с названием аналогичным названию проекта
add_executable(${CMAKE_PROJECT_NAME} ${SOURCES} ${HEADERS})
set_property(TARGET ${CMAKE_PROJECT_NAME} PROPERTY CXX_STANDARD 20)
target_compile_options(Example PRIVATE -Wall -Wextra -Werror -Wpedantic)

</code></pre>
<h2 id="запуск-clang-tidy-через-cmake">Запуск clang-tidy через CMake</h2>
<p><strong>CMake</strong> предоставляет встроенную поддержку <strong>clang-tidy</strong>. Для автоматического запуска при каждой сборке в конфиг нужно добавить следующую команду:</p>
<pre class=" language-cmake"><code class="prism  language-cmake">set(CMAKE_CXX_CLANG_TIDY "clang-tidy")
</code></pre>
<p><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_CLANG_TIDY.html">https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_CLANG_TIDY.html</a></p>
<p><strong>Clang-tidy</strong> будет запускаться каждый раз при сборке приложения только на измененных файлах, используя конфиг в корне проекта. Учтите, что это может увеличить время сборки.</p>
<h2 id="запуск-clang-format-через-cmake">Запуск clang-format через CMake</h2>
<p><strong>CMake</strong> позволяет добавлять собственные цели, допускающие любые команды, запускающиеся в консоли. Для этого используется команда <strong>add_custom_target</strong>.</p>
<p>Так можно добавить кастомную цель для запуска <strong>clang-format</strong> (имя цели тоже будет <strong>clang-format</strong>):</p>
<pre class=" language-cmake"><code class="prism  language-cmake">add_custom_target(
    clang-format
    COMMAND clang-format
    --dry-run
    -Werror
    ${SOURCES}
    ${HEADERS}
)
</code></pre>
<p>Чтобы запустить кастомную цель, необходимо в консоли явно указать ее при сборке. Для данного примера:</p>
<pre><code>cmake --build . --target clang-format
</code></pre>
<h2 id="настраиваемая-сборка-с-дебаггером">Настраиваемая сборка с дебаггером</h2>
<p>Для работы дебаггера необходимы дебажные символы, добавляемые компилятором при указании флага <strong>-g</strong> (для <strong>gcc</strong> и <strong>clang</strong>). Добавлять этот флаг без намерения дебажить приложение нецелесообразно. Поэтому можно использовать <strong>CMake</strong> для настраиваемой сборки: в случае необходимости, флаг будет добавлен, по умолчанию же он будет отключен.</p>
<p>Для этого в <strong>CMakeLists.txt</strong> добавим следующее:</p>
<pre class=" language-cmake"><code class="prism  language-cmake">if(ENABLE_DEBUG)
    target_compile_options(${CMAKE_PROJECT_NAME} PRIVATE -g)
endif()
</code></pre>
<p>Тут используется кастомный флаг <strong>ENABLE_DEBUG</strong> (название может быть почти любым). По умолчанию он не определен, а значит его значение - <strong>False</strong>.</p>
<p>Теперь при генерации файлов сборки необходимо подать этот флаг. Для удобства (чтобы не генерировать файлы сборки каждый раз заново при необходимости дебажить приложение) можно завести отдельную директорию, где будет собираться версия приложения для дебага, например <strong>build-debug</strong>.</p>
<p>Находясь в этой директории, нужно ввести следующую команду в консоль:</p>
<pre><code>cmake -DENABLE_DEBUG=True ..
</code></pre>
<p>Где после -D идет название флага (или любой другой нужной переменной) и устанавливается ее значение в <strong>True</strong> (если бы это была строковая переменная, то передали бы строку и т.п.).</p>
<p>После этого можно собрать приложение как обычно. В него компилятором будут добавлены дебажные символы.</p>
<blockquote>
<p>При использовании дебаггера в VS Code, не забудьте указать правильный путь к приложению в соответствующем конфиге в launch.json.</p>
</blockquote>
<h2 id="итоговый-вид-cmake-конфига">Итоговый вид CMake конфига</h2>
<pre class=" language-cmake"><code class="prism  language-cmake">cmake_minimum_required(VERSION 3.20)

project(Example)

set(CMAKE_CXX_CLANG_TIDY "clang-tidy")

set(SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/main.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/File2.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/File3.cpp
)

set(HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/Header1.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Header2.hpp
)

add_executable(${CMAKE_PROJECT_NAME} ${SOURCES} ${HEADERS})
set_property(TARGET ${CMAKE_PROJECT_NAME} PROPERTY CXX_STANDARD 20)
target_compile_options(Example PRIVATE -Wall -Wextra -Werror -Wpedantic)

if(ENABLE_DEBUG)
    target_compile_options(${CMAKE_PROJECT_NAME} PRIVATE -g)
endif()

add_custom_target(
    clang-format
    COMMAND clang-format
    --dry-run
    -Werror
    ${SOURCES}
    ${HEADERS}
)

</code></pre>
</div>
</body>

</html>
